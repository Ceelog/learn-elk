<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="preface.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li class="chapter-item expanded "><a href="what-is-elk.html"><strong aria-hidden="true">2.</strong> 什么是 ELK Stack</a></li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">3.</strong> 演示环境安装与配置</a></li><li class="chapter-item expanded "><a href="nginx.html"><strong aria-hidden="true">4.</strong> Nginx 访问日志</a></li><li class="chapter-item expanded "><a href="filebeat.html"><strong aria-hidden="true">5.</strong> Filebeat 日志收割</a></li><li class="chapter-item expanded "><a href="kafka.html"><strong aria-hidden="true">6.</strong> Kafka 消息队列</a></li><li class="chapter-item expanded "><a href="logstash.html"><strong aria-hidden="true">7.</strong> Logstash 处理日志</a></li><li class="chapter-item expanded "><a href="elasticsearch.html"><strong aria-hidden="true">8.</strong> Elasticsearch 索引日志</a></li><li class="chapter-item expanded "><a href="kibana.html"><strong aria-hidden="true">9.</strong> Kibana 分析日志</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kibana/query.html"><strong aria-hidden="true">9.1.</strong> 查询日志</a></li><li class="chapter-item expanded "><a href="kibana/visualize.html"><strong aria-hidden="true">9.2.</strong> 可视化报表</a></li><li class="chapter-item expanded "><a href="kibana/dashbord.html"><strong aria-hidden="true">9.3.</strong> Dashbord</a></li></ol></li><li class="chapter-item expanded "><a href="end.html"><strong aria-hidden="true">10.</strong> 结语</a></li><li class="chapter-item expanded "><a href="author.html"><strong aria-hidden="true">11.</strong> 关于作者</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/Ceelog/learn-elk" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#前言" id="前言">前言</a></h1>
<p>大数据时代，业务无时不刻在产生大量数据。如何挖掘这些数据的价值，已经成为每个公司的必修课。</p>
<p>工欲善其事，必先利其器，一款方便高效的工具，可以辅助我们实时洞察源源不断产生的数据，发现其中的价值。</p>
<p>ELK Stack 正是在这样一款工具。</p>
<p>准确来说 ELK Stack 是一组工具集合，可以完成数据采集、清洗过滤、运输存储、索引查询、交互式探索、可视化报表等一系列工作。</p>
<p>本小册全面介绍 ELK Stack 包含的各个组件及其使用方法，让零基础的读者也能轻松搭建整个套件，并运用到实际的生产环境中。</p>
<p>在示例中，我们将打造一个大规模日志实时分析系统，实现每天数十亿条日志或者 PB 级数据的分析处理。</p>
<p>事不宜迟，马上开始！</p>
<h1><a class="header" href="#什么是-elk-stack" id="什么是-elk-stack">什么是 ELK Stack</a></h1>
<p><img src="./imgs/elk-stack.jpg" alt="elk stack" /></p>
<p>ELK 是 3 款开源软件 <a href="https://github.com/elastic/elasticsearch">Elasticsearch</a> / <a href="https://github.com/elastic/Logstash">Logstash</a> / <a href="https://github.com/elastic/kibana">Kibana</a> 的简称，基于这 3 款软件及其相关组件组成的数据处理系统称之为 ELK Stack。</p>
<p>从上面的架构图可以清晰地看到各个组件以栈[Stack]的形式构成整个系统。</p>
<p>由于系统涉及的组件越来越多，比如 Filebeat、Metricbeat、Kafka、Zookeeper 等，而不仅仅是 ELK，所以 ELK Stack 也逐渐被称为 Elastic Stack。</p>
<p>下面，简单介绍 Elastic Stack 涉及的各个组件：</p>
<h2><a class="header" href="#elasticsearch" id="elasticsearch">Elasticsearch</a></h2>
<blockquote>
<p><a href="https://www.elastic.co/cn/elasticsearch">Elasticsearch</a> 是一个搜索和分析引擎，主要负责将日志索引并存储起来，方便业务方检索查询</p>
</blockquote>
<p><img src="./imgs/elasticsearch.jpg" alt="Elasticsearch" /></p>
<h2><a class="header" href="#logstash" id="logstash">Logstash</a></h2>
<blockquote>
<p><a href="https://www.elastic.co/cn/logstash">Logstash</a> 是服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中</p>
</blockquote>
<p><img src="./imgs/logstash.jpg" alt="Logstash" /></p>
<h2><a class="header" href="#kibana" id="kibana">Kibana</a></h2>
<blockquote>
<p><a href="https://www.elastic.co/cn/kibana">Kibana</a> 则可以让用户在 Elasticsearch 中使用图形和图表对数据进行可视化</p>
</blockquote>
<p><img src="./imgs/kibana.jpg" alt="Kibana" /></p>
<h2><a class="header" href="#kafka" id="kafka">Kafka</a></h2>
<blockquote>
<p>在生产环境中，为了提升系统的稳定性和可扩展性，会增加一层消息队列中间件，用来「削峰填谷」，从容应对各类突发流量，保障后端日志索引服务的平稳性。</p>
<p><a href="https://kafka.apache.org/">Kafka</a> 正是这样一款分布式消息队列服务中间件。</p>
</blockquote>
<p><img src="./imgs/Kafka-Intro.png" alt="Kafka" /></p>
<h2><a class="header" href="#filebeat" id="filebeat">Filebeat</a></h2>
<blockquote>
<p><a href="https://www.elastic.co/cn/beats/filebeat">Filebeat</a> 是轻量型日志采集器，用于转发和汇总日志与文件，让简单的事情不再繁杂。</p>
</blockquote>
<p><img src="./imgs/filebeat.png" alt="Filebeat" /></p>
<h2><a class="header" href="#小结" id="小结">小结</a></h2>
<p>基于 Elastic Stack 可以轻松打造大规模日志实时分析处理系统。</p>
<p>所谓「大规模」，指的是 Elastic Stack 支持每天收集、处理、索引数十甚至上百亿规模的各类日志，这主要得益于 Filebeat、Kafka、Logstash、Elasticsearch 都支持分布式部署，可以无限水平扩展。</p>
<p>各类文本形式的日志都在处理范围，本小册以最常见的 Nginx 访问日志为例，演示如何搭建大规模日志实时分析处理系统。对访问日志的实时分析，可以帮助我们随时掌握业务的运行状况、统计 PV/UV、发现异常流量、分析用户行为、查看热门站内搜索关键词等。</p>
<h1><a class="header" href="#演示环境安装与配置" id="演示环境安装与配置">演示环境安装与配置</a></h1>
<h2><a class="header" href="#本地开发环境" id="本地开发环境">本地开发环境</a></h2>
<p>为了深入理解各个组件的使用，建议读者在本地搭建一个开发环境。</p>
<p>为了解决系统环境和依赖的问题，本小册使用 Docker 容器运行各个组件，并使用 Docker Compose 进行服务编排，实现可「一键启动」的开发环境。</p>
<h3><a class="header" href="#docker-下载与安装" id="docker-下载与安装">Docker 下载与安装</a></h3>
<p>Docker 是一种容器化技术，可以将软件及其依赖的运行环境打包进一个容器中，和虚拟机不同的是，Docker 容器非常轻量，可以实现秒级的启动或关闭。</p>
<ul>
<li>
<p>Docker 支持 Linux / Windows / MacOS 平台。</p>
</li>
<li>
<p>在官网下载与安装 Docker <a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a></p>
</li>
<li>
<p>系统配置要求：</p>
<ul>
<li>4GB 以上内存</li>
<li>2 核以上 CPU</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#docker-desktop-for-windowsmac" id="docker-desktop-for-windowsmac">Docker Desktop for Windows/Mac</a></h4>
<p>为了支持 Windows 和 Mac 操作系统，Docker 开发了 Docker Desktop for Windows/Mac</p>
<p>以下是 Docker Desktop 运行起来的界面：</p>
<p><img src="./imgs/docker-desktop-mac.png" alt="Docker Desktop for Mac" /></p>
<p>可以通过设置页面，配置足够的计算资源：</p>
<p><img src="./imgs/docker-desktop-resource.png" alt="Docker Desktop Resource" /></p>
<h4><a class="header" href="#docker-for-linux" id="docker-for-linux">Docker for Linux</a></h4>
<p>由于 Docker 源于 Linux 虚拟化技术，所以对 Linux 操作系统支持的很好。</p>
<p>安装参见 <a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a></p>
<h4><a class="header" href="#启动-docker" id="启动-docker">启动 Docker</a></h4>
<p>Docker Desktop for Windows/Mac 安装完成后，直接双击图标就可以启动：</p>
<p><img src="./imgs/docker-desktop-start.png" alt="Docker Desktop start" /></p>
<p>Docker for Linux 安装完成后，需要先启动 Docker 服务：</p>
<pre><code>service docker start
</code></pre>
<p>启动成功后，可以在命令行查看 Docker 相关信息：</p>
<pre><code class="language-shell"># docker version
Client: Docker Engine - Community
 Version:           19.03.7
 API version:       1.40
 Go version:        go1.12.17
 Git commit:        7141c199a2
 Built:             Wed Mar  4 01:24:10 2020
 OS/Arch:           linux/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          19.03.7
  API version:      1.40 (minimum version 1.12)
  Go version:       go1.12.17
  Git commit:       7141c199a2
  Built:            Wed Mar  4 01:22:45 2020
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.2.13
  GitCommit:        7ad184331fa3e55e52b890ea95e65ba581ae3429
 runc:
  Version:          1.0.0-rc10
  GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd
 docker-init:
  Version:          0.18.0
</code></pre>
<p>如果没有启动成功，则会报错：</p>
<pre><code class="language-shell"># docker ps
Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?

</code></pre>
<h4><a class="header" href="#docker-compose" id="docker-compose">Docker Compose</a></h4>
<p>有了 Docker 后我们可以轻松运行各种软件，但是对于一个大型系统，涉及很多服务，以及服务之间的依赖关系。</p>
<p>如果手动处理各个服务、网络配置等计算资源，效率低下且容易出错。</p>
<p>这个时候可以使用 <a href="https://docs.docker.com/compose/">Docker Compose</a> 编排这些服务，实现大型系统的「一键启动」</p>
<p><img src="./imgs/docker-compose.jpg" alt="Docker Compose" /></p>
<h3><a class="header" href="#docker-配置" id="docker-配置">Docker 配置</a></h3>
<p>本小册演示环境的所有配置都已经开源并托管在 Github ，下载地址： </p>
<ul>
<li><a href="https://github.com/Ceelog/learn-elk">https://github.com/Ceelog/learn-elk</a> </li>
</ul>
<p>系统配置目录结构如下所示：</p>
<pre><code>.
├── docker-compose.yml
├── elasticsearch
│   ├── config
│   │   └── elasticsearch.yml
│   └── Dockerfile
├── .env
├── filebeat
│   ├── Dockerfile
│   └── filebeat.yml
├── kibana
│   ├── config
│   │   └── kibana.yml
│   └── Dockerfile
├── logstash
│   ├── config
│   │   └── logstash.yml
│   ├── Dockerfile
│   └── pipeline
│       ├── logstash.conf
│       └── nginx.conf
└── nginx
    ├── html
    │   └── index.html
    └── nginx.conf
</code></pre>
<p>其中 <code>.env</code> 文件声明使用 7.6.2 版本的 Elastic Stack:</p>
<pre><code class="language-shell">ELK_VERSION=7.6.2
</code></pre>
<p>如果你想测试其他版本的 Elastic Stack，只需修改<code>ELK_VERSION</code>参数即可。</p>
<h3><a class="header" href="#一键启动" id="一键启动">一键启动</a></h3>
<p>上述配置文件中，<code>docker-compose.yml</code> 声明了我们需要的服务以及如果构建这些服务。</p>
<p>Docker 安装并启动后，执行以下命令即可「一键启动」整个开发环境：</p>
<pre><code class="language-shell">cd learn-elk.git/docker-compose/

docker-compose -f &quot;docker-compose.yml&quot; up -d --build
</code></pre>
<pre><code class="language-shell"># 运行结果
Creating network &quot;learn-elkgit_elk&quot; with driver &quot;bridge&quot;
Creating network &quot;learn-elkgit_default&quot; with the default driver

Building elasticsearch
Step 1/2 : ARG ELK_VERSION
Step 2/2 : FROM docker.elastic.co/elasticsearch/elasticsearch:${ELK_VERSION}
 ---&gt; f29a1ee41030
Successfully built f29a1ee41030
Successfully tagged learn-elkgit_elasticsearch:latest
Building logstash
Step 1/2 : ARG ELK_VERSION
Step 2/2 : FROM docker.elastic.co/logstash/logstash:${ELK_VERSION}
 ---&gt; fa5b3b1e9757
Successfully built fa5b3b1e9757
Successfully tagged learn-elkgit_logstash:latest
Building kibana
Step 1/2 : ARG ELK_VERSION
Step 2/2 : FROM docker.elastic.co/kibana/kibana:${ELK_VERSION}
 ---&gt; f70986bc5191
Successfully built f70986bc5191
Successfully tagged learn-elkgit_kibana:latest
Building filebeat
Step 1/2 : ARG ELK_VERSION
Step 2/2 : FROM docker.elastic.co/beats/filebeat:${ELK_VERSION}
 ---&gt; 0272ee9a7757
Successfully built 0272ee9a7757
Successfully tagged learn-elkgit_filebeat:latest
Creating learn-elkgit_nginx_1         ... done
Creating learn-elkgit_zookeeper_1     ... done
Creating learn-elkgit_elasticsearch_1 ... done
Creating learn-elkgit_kafka_1         ... done
Creating learn-elkgit_kibana_1        ... done
Creating learn-elkgit_logstash_1      ... done
Creating learn-elkgit_filebeat_1      ... done
Creating learn-elkgit_kafdrop_1       ... done
Creating learn-elkgit_metricbeat_1    ... done

</code></pre>
<blockquote>
<p>注意：首次启动的时候，需要下载镜像文件，可能需要数十分钟，请耐心等候一下</p>
</blockquote>
<p>如果你使用 VSCode 编辑器 并且 安装了 Docker 插件，那么你可以看到运行中的容器状态：</p>
<p><img src="./imgs/docker-containers.png" alt="Docker Containers" /></p>
<h2><a class="header" href="#小结-1" id="小结-1">小结</a></h2>
<p>本小节介绍了在线演示环境使用、本地开发环境搭建，在这个过程中读者也对整个系统有了大概的认识。</p>
<p>接下来，我们深入每个模块，了解其配置和运行环境。</p>
<h2><a class="header" href="#常见问题" id="常见问题">常见问题</a></h2>
<ul>
<li>filebeat 启动报错：</li>
</ul>
<pre><code class="language-shell">Exiting: error loading config file: 
config file (&quot;filebeat.yml&quot;) can only be writable by the owner but the permissions are &quot;-rw-rw-r--&quot; 
(to fix the permissions use: 'chmod go-w /usr/share/filebeat/filebeat.yml')
</code></pre>
<p>原因：如果在 Linux 系统下启动，需要保证 filebeat 配置文件的读写权限正确，否则 Filebaet 容器无法启动并报错</p>
<p>解决方法：修改 filebeat 配置文件权限 <code>chmod 644 filebeat.yml</code></p>
<h1><a class="header" href="#nginx-访问日志" id="nginx-访问日志">Nginx 访问日志</a></h1>
<h2><a class="header" href="#nginx-服务配置" id="nginx-服务配置">Nginx 服务配置</a></h2>
<p>在 docker-compose.yaml 对于 Nginx 服务的配置中：</p>
<pre><code class="language-yaml"> nginx:
    image: nginx:1.18
    ports:
    - &quot;8000:80&quot;
    volumes:
      - &quot;./nginx/nginx.conf:/etc/nginx/nginx.conf:ro&quot;
      - &quot;./nginx/html:/usr/share/nginx/html:ro&quot;
      - type: volume
        source: nginx-log
        target: /var/log/nginx
</code></pre>
<ul>
<li>使用 Nginx 1.18 版本的官方镜像，默认使用的镜像仓库地址为： <a href="https://hub.docker.com/_/nginx">https://hub.docker.com/_/nginx</a></li>
<li>将宿主机的 8000 端口映射到到 Nginx 容器内的 80 端口，这样就可以通过宿主机地址访问容器内服务</li>
<li>数据卷映射：
<ul>
<li>将宿主机目录下的配置文件 以及 <code>html</code> 目录映射到容器内相应的目录，这样容器内应用就可以访问宿主机上的文件或目录</li>
<li>使用宿主机上名为 <code>nginx-log</code> 的数据卷，并映射到容器内的 <code>/var/log/nginx</code> 目录，目的是让运行在同一宿主机上的容器之间共享目录</li>
<li>Filebeat 容器也会用到 <code>nginx-log</code> 数据卷，在这个目录收割 Nginx 访问日志</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#nginx-配置" id="nginx-配置">Nginx 配置</a></h2>
<p>对于 <code>nginx/nginx.conf</code> 配置：</p>
<pre><code class="language-nginx">user  nginx;
worker_processes  1;

error_log  /var/log/nginx/elk-error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent $request_time &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    access_log  /var/log/nginx/elk-access.log  main;

    sendfile        on;
    gzip  on;
    
    server {
        listen       80;

        rewrite ^(.*)$ /index.html;

        location / {
            root   /usr/share/nginx/html;
            index  index.html index.htm;
        }
    }
}
</code></pre>
<p>通过配置 Nginx 日志格式，可以将每个用户的访问信息记录到日志中，主要包括以下字段：</p>
<ul>
<li><code>$remote_addr</code> 用户 ip 地址</li>
<li><code>$remote_user</code> 用户标识</li>
<li><code>$time_local</code> 服务器时间</li>
<li><code>$request</code> http 请求头信息，包括 http method / uri / http 版本</li>
<li><code>$status</code> 服务器响应状态码，例如 200/302/404/504</li>
<li><code>$body_bytes_sent</code> 服务器响应内容大小(单位 bytes)</li>
<li><code>$request_time</code> 请求处理时间</li>
<li><code>$http_referer</code> 请求来源 referer</li>
<li><code>$http_user_agent</code> 用户系统/浏览器等信息</li>
<li><code>$http_x_forwarded_for</code> 网络代理 ip 列表(如果使用代理)</li>
</ul>
<p>日志示例：</p>
<pre><code class="language-shell">#tail -f /var/log/nginx/elk-access.log 
192.168.0.1 - - [26/May/2020:12:31:31 +0000] &quot;GET /api/news/view HTTP/1.0&quot; 404 555 0.000 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36&quot; &quot;-&quot;
192.168.0.1 - - [26/May/2020:12:31:32 +0000] &quot;GET /api/app/update HTTP/1.0&quot; 404 555 0.000 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36&quot; &quot;-&quot;
192.168.0.1 - - [26/May/2020:12:31:32 +0000] &quot;GET /api/user/login HTTP/1.0&quot; 404 555 0.000 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36&quot; &quot;-&quot;
</code></pre>
<p>这些日志将被 Filebeat 采集后投递到 Kafka 消息队列，再经过 Logstash 的格式化处理后，索引到 Elasticsearch 中，最后通过 Kibana 可视化查询。</p>
<h2><a class="header" href="#运行效果" id="运行效果">运行效果</a></h2>
<p><img src="./imgs/nginx-web.jpg" alt="Nginx Web" /></p>
<h1><a class="header" href="#filebeat-日志收割" id="filebeat-日志收割">Filebeat 日志收割</a></h1>
<h2><a class="header" href="#filebeat-服务配置" id="filebeat-服务配置">Filebeat 服务配置</a></h2>
<p>在 docker-compose.yaml 对于 Filebeat 服务的配置中：</p>
<pre><code class="language-yaml">filebeat:
    build:
      context: filebeat/
      args:
        ELK_VERSION: $ELK_VERSION
    volumes:
      - &quot;./filebeat/filebeat.yml:/usr/share/filebeat/filebeat.yml:ro&quot;
      - type: volume
        source: nginx-log
        target: /var/log
    depends_on:
      - nginx
    networks:
      - elk
</code></pre>
<ul>
<li>使用 filebeat/ 目录下的 Dockerfile 构建镜像</li>
<li>数据卷映射：
<ul>
<li>将宿主机目录下的配置文件映射到容器内</li>
<li>使用宿主机上名为 nginx-log 的数据卷，并映射到容器内的 <code>/var/log</code> 目录，这和 Nginx 容器使用的是同一个目录</li>
</ul>
</li>
<li>Filebeat 服务依赖于 Nginx 服务，所以 Docker Compose 会先启动 Nginx ，然后再启动 Filebeat</li>
<li>使用名为 elk 的子网络，这样便可以访问同样使用这个子网络的其他容器</li>
</ul>
<h2><a class="header" href="#filebeat-日志收割配置" id="filebeat-日志收割配置">Filebeat 日志收割配置</a></h2>
<p>对于 <code>filebeat/filebeat.yml</code> 配置：</p>
<pre><code class="language-yaml">filebeat.inputs:
  - type: log
    paths:
      - /var/log/*access.log
    encoding: utf-8
    fields:
      topic: nginx-log
    scan_frequency: 1s
    harvester_buffer_size: 16384
    tail_files: false
    close_eof: true
    clean_removed: true
  
processors:
  - drop_fields:
      fields: [&quot;ecs&quot;, &quot;input&quot;, &quot;host&quot;, &quot;agent&quot;, &quot;log.offset&quot;]
      ignore_missing: true

#------------------------------- Kafka output ---------------------------------
output.kafka:
  enabled: true
  hosts: [&quot;kafka:9092&quot;]
  topic: elk-%{[fields.topic]}
  worker: 2
  keep_alive: 60
  required_acks: 1
</code></pre>
<p>Filebeat 通过配置 input / processors / output 模块，实现日志收集、预处理、投递等工作</p>
<p>对于 input 模块：</p>
<ul>
<li><code>type</code> 配置数据来源的类型，例如 文本日志 log 或者 控制台输出 stdout</li>
<li><code>paths</code> 指定日志的路径，可以使用模糊匹配，例如 <code>/var/log/*access.log</code></li>
<li><code>encoding</code> 日志的编码，例如 utf-8</li>
<li><code>fields</code> 自定义添加的字段，例如 增加一个主题字段 <code>topic: nginx-log</code></li>
<li><code>scan_frequency: 1s</code> 扫描日志文件的间隔</li>
<li><code>harvester_buffer_size: 16384</code> 日志收割缓存大小</li>
<li><code>tail_files: false</code> 启动 filebeat 后，是否从目标日志文件的结尾开始收集</li>
<li><code>close_eof: true</code> 采集日志到文件结尾的时候，是否关闭采集进程</li>
<li><code>clean_removed: true</code> 采集目标日志文件被移除后，是否从 filebeat registry 清楚</li>
</ul>
<p>更全面的配置信息，请参考：</p>
<ul>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-log.html">https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-log.html</a></li>
</ul>
<p>对于 processors 模块：</p>
<ul>
<li><code>drop_fields</code> 可以舍弃部分多余字段</li>
</ul>
<p>对于 output 模块：</p>
<ul>
<li><code>output.kafka</code> 将收集的日志投递到 Kafka 消息队列</li>
<li><code>hosts: [&quot;kafka:9092&quot;]</code> 指定 Kafka 服务的地址</li>
<li><code>topic: elk-%{[fields.topic]}</code> 指定投递到 Kafka 消息队列的频道</li>
<li><code>keep_alive: 60</code> Filebeat 和 Kafka 之间保持连接的时间</li>
<li><code>required_acks: 1</code> 日志消息投递后，是否需要等待 Kafka 的确认反馈</li>
</ul>
<p>更全面的配置信息，请参考：</p>
<ul>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/kafka-output.html">https://www.elastic.co/guide/en/beats/filebeat/current/kafka-output.html</a></li>
</ul>
<h2><a class="header" href="#小结-2" id="小结-2">小结</a></h2>
<p>Filebeat 启动后，开始监听目标文件，当发现新日志后就收集转发出去。</p>
<h1><a class="header" href="#kafka-消息队列" id="kafka-消息队列">Kafka 消息队列</a></h1>
<h2><a class="header" href="#kafka-服务配置" id="kafka-服务配置">Kafka 服务配置</a></h2>
<p>在 docker-compose.yaml 对于 Kafka 服务的配置中：</p>
<pre><code class="language-yaml">  zookeeper:
    image: wurstmeister/zookeeper
    ports:
      - &quot;2181:2181&quot;
    networks:
      - elk
  
  kafka:
    image: wurstmeister/kafka:2.12-2.1.0
    ports:
      - &quot;9092:9092&quot;
    environment:
      KAFKA_ADVERTISED_HOST_NAME: $HOST_IP
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_HEAP_OPTS: &quot;-Xmx512M -Xms512M&quot;
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    depends_on:
      - zookeeper
    networks:
      - elk

  kafdrop:
    image: obsidiandynamics/kafdrop
    ports:
      - &quot;9000:9000&quot;
    environment:
      KAFKA_BROKERCONNECT: kafka:9092
      JVM_OPTS: &quot;-Xms32M -Xmx64M&quot;
      SERVER_SERVLET_CONTEXTPATH: &quot;/&quot;
    depends_on:
      - kafka
    networks:
      - elk
</code></pre>
<ul>
<li>Kafka 依赖 zookeeper 提供分布式状态存储服务</li>
<li>注意选择 Kafka 的版本和 ELK 兼容，这里选的是 <code>wurstmeister/kafka:2.12-2.1.0</code></li>
<li>使用名为 elk 的子网络，这样便可以访问同样使用这个子网络的其他容器</li>
<li>使用 Kafka 可视化管理工具 Kafdrop 可以查看 Kafka 当前运行状态</li>
</ul>
<h2><a class="header" href="#kafdrop-可视化管理后台" id="kafdrop-可视化管理后台">Kafdrop 可视化管理后台</a></h2>
<p><a href="https://github.com/obsidiandynamics/kafdrop">Kafdrop</a> 是一款 Kafka web ui 软件，支持丰富的管理功能，包括：</p>
<ul>
<li>查看 Kafka 节点</li>
<li>查看/创建 Topics</li>
<li>浏览消息</li>
<li>查看 consumer groups</li>
<li>...</li>
</ul>
<p><img src="./imgs/kafka-overview.png" alt="Kafka Overview" /></p>
<h2><a class="header" href="#小结-3" id="小结-3">小结</a></h2>
<p>Kafka 作为消息队列服务，具有高吞吐、低延迟、高并发、高可用等优点，应用到 Elastic Stack 中可以显著提升整个系统的稳定性。</p>
<p>成百上千的 Filebeat 实例可以即时地将大量日志转发到 Kafka，再由 Logstash 按照阈值能力慢慢处理，达到「削峰填谷」的效果。</p>
<h1><a class="header" href="#logstash-处理日志" id="logstash-处理日志">Logstash 处理日志</a></h1>
<h2><a class="header" href="#logstash-服务配置" id="logstash-服务配置">Logstash 服务配置</a></h2>
<p>在 docker-compose.yaml 对于 Logstash 服务的配置中：</p>
<pre><code class="language-yaml">  logstash:
    build:
      context: logstash/
      args:
        ELK_VERSION: $ELK_VERSION
    volumes:
      - type: bind
        source: ./logstash/config/logstash.yml
        target: /usr/share/logstash/config/logstash.yml
        read_only: true
      - type: bind
        source: ./logstash/pipeline
        target: /usr/share/logstash/pipeline
        read_only: true
    ports:
      - &quot;9600:9600&quot;
    environment:
      LS_JAVA_OPTS: &quot;-Xmx256m -Xms256m&quot;
    networks:
      - elk
    depends_on:
      - elasticsearch
</code></pre>
<ul>
<li>使用 logstash/ 目录下的 Dockerfile 构建镜像</li>
<li>数据卷映射：
<ul>
<li>将宿主机目录下的配置文件映射到容器内</li>
</ul>
</li>
<li>使用名为 elk 的子网络，这样便可以访问同样使用这个子网络的其他容器</li>
</ul>
<h2><a class="header" href="#logstash-pipeline-配置" id="logstash-pipeline-配置">Logstash Pipeline 配置</a></h2>
<p>在 <code>logstash/pipeline/nginx.conf</code> 配置：</p>
<pre><code class="language-yaml">### INPUTS
input {
    kafka  {
      codec =&gt; &quot;json&quot;
      topics_pattern =&gt; &quot;elk-nginx-log&quot;
      bootstrap_servers =&gt; &quot;kafka:9092&quot;
      auto_offset_reset =&gt; &quot;latest&quot;
      group_id =&gt; &quot;nginx-log&quot;
    }
}

### FILTERS
filter {

    grok {

      #获取 Nginx 日志字段
      match =&gt; {
          &quot;message&quot; =&gt; [
          #Nginx access log 格式
          # 172.19.0.1 - - [21/May/2020:09:34:14 +0000] &quot;GET /index.html?f=hello HTTP/1.1&quot; 200 5 0.000 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.92 Safari/537.36&quot; &quot;-&quot;
          '%{IPV4:ip} - - \[%{HTTPDATE:[@metadata][timestamp]}\] &quot;%{WORD:method} %{URIPATH:path}(?:%{GREEDYDATA:query}|) HTTP/%{NUMBER}&quot; %{NUMBER:status} (?:%{NUMBER:body_bytes_sent}) (?:%{NUMBER:request_time}) %{QS:http_referer} %{QS:http_user_agent} %{QS:http_x_forwarded_for}'
          ]
      }

      remove_field =&gt; [&quot;message&quot;]
    }
    
    if [path] {

      # 过滤日志
      if [path] =~ /\.js|css|jpeg|jpg|png|gif|ico|swf|svg$/ {
        drop {}
      }

      #获取 日志 时间
      date {
          match =&gt; [ &quot;[@metadata][timestamp]&quot;, &quot;dd/MMM/yyyy:HH:mm:ss Z&quot; ]
          remove_field =&gt; [&quot;input_type&quot;, &quot;offset&quot;, &quot;tags&quot;, &quot;beat&quot; ]
      }

      mutate {
          #转换数据类型
          convert =&gt; [
              &quot;status&quot; , &quot;integer&quot;,
              &quot;body_bytes_sent&quot; , &quot;integer&quot;,
              &quot;request_time&quot;, &quot;float&quot;
          ]
      }

      if [query] {
        kv {
          prefix =&gt; &quot;p_&quot;
          source =&gt; &quot;query&quot;
          field_split =&gt; &quot;&amp;?&quot;

          #只存储感兴趣参数
          #include_keys =&gt; [ &quot;uid&quot;, &quot;vn&quot; ]
          remove_field =&gt; [&quot;query&quot; ]
        }

        #url 解码
        urldecode {
          all_fields =&gt; true
        }
      }
    }
}


### OUTPUTS

output {

  elasticsearch {
    hosts =&gt; &quot;elasticsearch:9200&quot;
    index =&gt; &quot;logstash-%{[fields][topic]}-%{+YYYY.MM.dd.HH}&quot;
  }
}
</code></pre>
<p>Logstash pipeline 配置主要分为 3 个部分： <code>input</code>/<code>filter</code>/<code>output</code></p>
<p>对于 <code>input</code> 模块：</p>
<ul>
<li>配置数据来源，这里是从 Kafka 获取日志</li>
<li>更多来源配置，参见 <a href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html">https://www.elastic.co/guide/en/logstash/current/input-plugins.html</a></li>
</ul>
<p>对于 <code>filter</code> 模块：</p>
<ul>
<li>配置数据过滤或格式化规则，这里主要使用 <code>grok</code> 和 <code>kv</code> 匹配日志字段和解析请求参数</li>
<li>更多过滤器配置，参见 <a href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html">https://www.elastic.co/guide/en/logstash/current/filter-plugins.html</a></li>
</ul>
<p>对于 <code>output</code> 模块：</p>
<ul>
<li>配置格式化后的数据输出目标，这里将日志输出到 Elasticsearch </li>
<li>更多输出配置，参见 <a href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html">https://www.elastic.co/guide/en/logstash/current/output-plugins.html</a></li>
</ul>
<h3><a class="header" href="#关于-grok" id="关于-grok">关于 Grok</a></h3>
<p>Grok 是正则匹配工具，更多正则模式请参考 <a href="https://grokdebug.herokuapp.com/patterns#">https://grokdebug.herokuapp.com/patterns#</a></p>
<p><img src="./imgs/grok-debugger.png" alt="Grok Debugger" /></p>
<h1><a class="header" href="#elasticsearch-索引日志" id="elasticsearch-索引日志">Elasticsearch 索引日志</a></h1>
<h2><a class="header" href="#elasticsearch-服务配置" id="elasticsearch-服务配置">Elasticsearch 服务配置</a></h2>
<p>在 docker-compose.yaml 对于 Elasticsearch 服务的配置中：</p>
<pre><code class="language-yaml">  elasticsearch:
    build:
      context: elasticsearch/
      args:
        ELK_VERSION: $ELK_VERSION
    volumes:
      - type: bind
        source: ./elasticsearch/config/elasticsearch.yml
        target: /usr/share/elasticsearch/config/elasticsearch.yml
        read_only: true
      - type: volume
        source: elasticsearch
        target: /usr/share/elasticsearch/data
    ports:
      - &quot;9200:9200&quot;
      - &quot;9300:9300&quot;
    environment:
      ES_JAVA_OPTS: &quot;-Xmx512m -Xms512m&quot;
      ELASTIC_PASSWORD: changeme
      # Use single node discovery in order to disable production mode and avoid bootstrap checks
      # see https://www.elastic.co/guide/en/elasticsearch/reference/current/bootstrap-checks.html
      discovery.type: single-node
    networks:
      - elk
</code></pre>
<ul>
<li>使用 elasticsearch/ 目录下的 Dockerfile 构建镜像</li>
<li>数据卷映射：
<ul>
<li>将宿主机目录下的配置文件映射到容器内</li>
<li>使用宿主机上名为elasticsearch 的数据卷，并映射到容器内的 <code>/usr/share/elasticsearch/data</code> 目录，这样可以长久保存日志数据</li>
</ul>
</li>
<li>使用名为 elk 的子网络，这样便可以访问同样使用这个子网络的其他容器</li>
</ul>
<h1><a class="header" href="#kibana-分析日志" id="kibana-分析日志">Kibana 分析日志</a></h1>
<h2><a class="header" href="#kibana-服务配置" id="kibana-服务配置">Kibana 服务配置</a></h2>
<p>在 docker-compose.yaml 对于 Kibana 服务的配置中：</p>
<pre><code class="language-yaml">  kibana:
    build:
      context: kibana/
      args:
        ELK_VERSION: $ELK_VERSION
    volumes:
      - type: bind
        source: ./kibana/config/kibana.yml
        target: /usr/share/kibana/config/kibana.yml
        read_only: true
    ports:
      - &quot;5601:5601&quot;
    networks:
      - elk
    depends_on:
      - elasticsearch
</code></pre>
<ul>
<li>使用 kibana/ 目录下的 Dockerfile 构建镜像</li>
<li>数据卷映射：
<ul>
<li>将宿主机目录下的配置文件映射到容器内</li>
</ul>
</li>
<li>使用名为 elk 的子网络，这样便可以访问同样使用这个子网络的其他容器</li>
</ul>
<h2><a class="header" href="#运行效果-1" id="运行效果-1">运行效果</a></h2>
<p><img src="./imgs/kibana-welcome.jpg" alt="Kibana Welcome" /></p>
<h1><a class="header" href="#查询日志" id="查询日志">查询日志</a></h1>
<h2><a class="header" href="#创建-index-pattern" id="创建-index-pattern">创建 Index Pattern</a></h2>
<p>Nginx 访问日志经过收集、过滤、索引后就可以通过 Kibana 查询，但是查询之前需要指定索引 index pattern:</p>
<p><img src="kibana/../imgs/kibana-index-pattern.png" alt="Kibana Index Pattern" /></p>
<p>如上述截图示例，在 Kibana 管理 &gt; Index Patterns &gt; Creata Index Pattern 进入创建页面：</p>
<p><img src="kibana/../imgs/kibana-create-index-pattern.jpg" alt="kibana-create-index-pattern" /></p>
<p>Index Pattern 的名称是由 Logstash 配置的时候确定的：</p>
<pre><code class="language-yaml">#logstash/pipeline/nginx.conf

output {

  elasticsearch {
    hosts =&gt; &quot;elasticsearch:9200&quot;
    index =&gt; &quot;logstash-%{[fields][topic]}-%{+YYYY.MM.dd.HH}&quot;
  }
}

</code></pre>
<h2><a class="header" href="#查询日志-1" id="查询日志-1">查询日志</a></h2>
<p>在搜索框输入要查询的字段的值，同时在右侧选择时间区间，就可以开始查询索引的日志：</p>
<p><img src="kibana/../imgs/kibana-query-demo.png" alt="Kibana Query" /></p>
<h2><a class="header" href="#查询语法" id="查询语法">查询语法</a></h2>
<ul>
<li>
<p>精准查询：</p>
<ul>
<li><code>ip:&quot;192.168.42.10&quot;</code></li>
<li><code>path:&quot;/api/user/login&quot;</code></li>
<li><code>status:404</code></li>
</ul>
</li>
<li>
<p>模糊查询：</p>
<ul>
<li><code>p_key:&quot;关键词*&quot;</code></li>
</ul>
</li>
<li>
<p>AND 与查询：</p>
<ul>
<li><code>ip:&quot;192.168.42.10&quot; AND status:404</code></li>
</ul>
</li>
<li>
<p>OR 或查询：</p>
<ul>
<li><code>ip:&quot;192.168.42.10&quot; OR status:404</code></li>
<li><code>(ip:&quot;192.168.42.10&quot; AND status:404) OR (ip:&quot;192.168.42.11&quot; AND status:503)</code></li>
</ul>
</li>
<li>
<p>NOT 非查询：</p>
<ul>
<li><code>NOT ip:&quot;192.168.42.10&quot;</code></li>
</ul>
</li>
<li>
<p>比较查询：</p>
<ul>
<li><code>status &gt;= 500</code></li>
</ul>
</li>
</ul>
<p>更多查询语法，参考 <a href="https://www.elastic.co/guide/en/kibana/7.7/kuery-query.html">https://www.elastic.co/guide/en/kibana/7.7/kuery-query.html</a></p>
<h1><a class="header" href="#可视化" id="可视化">可视化</a></h1>
<p>Kibana 可以创建 面积图、饼图、折线图、表格、直方图、热力图、地理分布图等各种样式的可视化图表：</p>
<p><img src="kibana/../imgs/kibana-create-visualize.png" alt="Visualize" /></p>
<h2><a class="header" href="#面积图示例" id="面积图示例">面积图示例</a></h2>
<p><img src="kibana/../imgs/kibana-visualization-area.png" alt="Area" /></p>
<h2><a class="header" href="#饼图示例" id="饼图示例">饼图示例</a></h2>
<p><img src="kibana/../imgs/kibana-visualization-pie.png" alt="Pie" /></p>
<h2><a class="header" href="#tsvb示例" id="tsvb示例">TSVB示例</a></h2>
<p><img src="kibana/../imgs/kibana-tsvb.jpg" alt="TSVB" /></p>
<h1><a class="header" href="#dashbord" id="dashbord">Dashbord</a></h1>
<h2><a class="header" href="#创建-dashbord" id="创建-dashbord">创建 Dashbord</a></h2>
<p>将上一节创建的可视化图表聚合到一个页面上就是 Dashbord，有了实时大盘便可以全面感知业务运行状态。</p>
<p>首先需要新建一个 Dashbord，然后加入可视化图表：</p>
<p><img src="kibana/../imgs/kibana-create-dashbord.jpg" alt="" /></p>
<h2><a class="header" href="#dashbord-示例" id="dashbord-示例">Dashbord 示例</a></h2>
<p><img src="kibana/../imgs/kibana-dashbord.png" alt="Dashbord" /></p>
<h1><a class="header" href="#结语" id="结语">结语</a></h1>
<p>恭喜你！完成了整个 Elastic Stack 的学习。</p>
<p>现在，你拥有了搭建大规模日志实时分析系统的能力，马上试试应用的实际工作中去吧！</p>
<h1><a class="header" href="#关于作者" id="关于作者">关于作者</a></h1>
<ul>
<li>关注作者微信：</li>
</ul>
<p><img src="./imgs/ceelog.jpg" alt="Ceelog" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
